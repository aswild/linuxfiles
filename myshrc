#! /bin/bash
# Allen's unified custom shell config and alias script for bash and zsh

# Shell Options
export FIGNORE=".o:.pyc:~"
export EDITOR="vim"
set -o ignoreeof

# color and smart-case search for less
export LESS=Ri

# by default systemctl/journalctl sets LESS to FRSXMK,
# remove X (disable termcap alternate screen) to enable mouse scrolling
# remove S to allow line wrapping
# add i for ignore case search
export SYSTEMD_LESS=FRMKi

if [[ -t 1 ]]; then
    # if we're in a terminal, disable C-S and C-Q flow control handling
    stty -ixon
fi

function pathadd {
    ( [[ -n $1 ]] && [[ -n $2 ]] ) || return 1
    local OLDPATH
    eval OLDPATH="\$$1"

    if [[ :$OLDPATH: != :*$2*: ]]; then
        if [[ $3 == "append" ]]; then
            local NEWPATH=$OLDPATH:$2
        else
            local NEWPATH=$2:$OLDPATH
        fi
    else
        local NEWPATH=$OLDPATH
    fi
    echo -E -n "$NEWPATH" | sed -e 's/^://' -e 's/:$//'
}
[[ -d $HOME/bin ]] && export PATH="$(pathadd PATH $HOME/bin)"
[[ -d $HOME/scripts ]] && export PATH="$(pathadd PATH $HOME/scripts)"
#[[ -d $HOME/lib ]] && export LD_LIBRARY_PATH="$(pathadd LD_LIBRARY_PATH $HOME/lib)"

# function to filter out paths
#   $1 : variable to check (e.g. PATH)
#   $2 : egrep regex applied to each PATH entry
function path_filter {
    # filter out paths matching this regex
    local OLDPATH
    eval OLDPATH="\$$1"
    local NEWPATH=''
    while read -r -d: entry; do
        if ! egrep -q -e "$2" <<<"$entry"; then
            NEWPATH="$NEWPATH:$entry"
        fi
    done <<<"${OLDPATH}:"

    echo "${NEWPATH#:}"
}
[[ -d /mnt/c/Windows ]] && export PATH="$(path_filter PATH '/mnt/c/(Python|cygwin)')"
[[ -d /cygdrive ]] && export PATH="$(path_filter PATH '/cygdrive/c/(Python|Dwimperl)')"

# colors for ls
[[ -e ~/.dircolors ]] && eval `dircolors ~/.dircolors`

# Core aliases
alias 0='cd "$PWD"'
alias ls='ls --color=auto --group-directories-first'
alias lsl='ls -alh --color=auto --group-directories-first'
alias df='df -h'
alias du='du -h'
alias lspath='echo $PATH | tr ":" "\n"'
alias af='ag --nocolor -lG'

function psag {
    local __grep
    if which ag &>/dev/null; then
        __grep=ag
    else
        __grep='egrep --color=auto'
    fi
    local __pattern="$1"
    if [[ "${1:0:1}" =~ ^[A-Za-z0-9/] ]]; then
        __pattern="[${1:0:1}]${1:1}"
    fi
    ps aux | $__grep -- "$__pattern"
}

function man {
    # pretty man pages
    # mb = blink (rarely seen)
    # md = bold (bold, section headings, and option names)
    # so = standout (reverse video, status line)
    # us = underline (e.g. option arguments)
    LESS_TERMCAP_mb=$'\e[1;36m' \
    LESS_TERMCAP_md=$'\e[1;37m' \
    LESS_TERMCAP_so=$'\e[1;33m' \
    LESS_TERMCAP_us=$'\e[1;4m' \
    LESS_TERMCAP_me=$'\e[0m' \
    LESS_TERMCAP_se=$'\e[0m' \
    LESS_TERMCAP_ue=$'\e[0m' \
        command man "$@"
}

# networking/sudo aliases
if [[ ! -d /cygdrive ]] && [[ $USER != root ]] && ( sudo -l -S </dev/null &>/dev/null ); then
    _sudo_aliases=(apt apt-get ifconfig ifdown ifup ip pacman systemctl yum)
    for _cmd in "${_sudo_aliases[@]}"; do
        if /usr/bin/which "$_cmd" &>/dev/null; then
            alias "$_cmd"="sudo $_cmd"
        fi
    done
    unset _sudo_aliases _cmd
fi

# Conditional aliases
# ubuntu-specific
[[ -d /etc/update-motd.d ]] && alias update-motd='sudo run-parts /etc/update-motd.d | sudo tee /run/motd.dynamic'
[[ -x /usr/lib/update-notifier/update-motd-reboot-required ]] && alias rboot='/usr/lib/update-notifier/update-motd-reboot-required || echo "No Update Needed"'
alias findmod='find /lib/modules/$(uname -r) -name "*.ko" | grep -i'

# git aliases/functions (alphabetical)
alias gam='git commit -v --amend'
alias gb='git branch'
alias gba='git branch -a'
alias gc='git commit -v'
alias gca='git commit -v -a'
alias gcam='git commit -a -m'
alias gcm='git commit -m'
alias gd='git diff'
alias gdh='git diff HEAD'
alias gdn='git diff --name-status'
alias gds='git diff --staged'
function gdiffall {
    (
        gbase
        gvim -c "set diffopt=filler,vertical | tabdo :Gdiff $1" -p $(git diff --name-only $1)
    )
}
alias gfp='git format-patch -N'
alias gl='git pull'
alias glr='git pull --rebase'
alias glg='git log --oneline --decorate --color --graph'
alias glga='git log --oneline --decorate --color --graph --all'
function glgu {
    local _upstream
    if _upstream="$(git rev-parse --symbolic-full-name @{u})"; then
        if (( $# > 0 )); then
            local _opts=( --decorate --color --graph "$@" )
        else
            local _opts=( --decorate --color --graph --oneline )
        fi
        git log "${_opts[@]}" "${_upstream}.."
    else
        return $?
    fi

}
alias gll='git log --decorate --color --graph --name-status'
alias glla='git log --decorate --color --graph --name-status --all'
alias gllp='git log --decorate --color --graph --patch'
alias gllu='glgu --name-status'
alias gllup='glgu --patch'
alias gp='git push'
alias gri='git rebase -i'
alias grv='git remote -v'
alias gs='git status'
alias gss='git status --short'
alias gsh='git show --decorate'
alias gshn='git show --name-status --decorate'

[[ -n $ZSH_NAME ]] && [[ -x $(which smartless) ]] && export GIT_PAGER="$(which smartless)"

# wrap gitk in a function to automatically run it in the background
function gitk {
    command gitk "$@" &
}

function gbase {
    local dir=$(git rev-parse --show-toplevel 2>/dev/null)
    [[ -n $dir ]] && cd $dir
}

# Core functions
function mdcd {
    mkdir -p "$1" && cd "$1"
}

function cdh {
    [[ -n "$1" ]] || return 1
    local _dir
    while read _dir; do
        if grep -q "$1" <<<"$_dir"; then
            cd "$_dir"
            return 0
        fi
    done < <(dirs -v | cut -f2)
    echo "No history dir matching '$1' found"
    return 1
}

unalias ll 2>/dev/null
function ll {
    ls -lAh --color=always --group-directories-first "$@" | sed 's/[ ]\+/ /g' |  cut -d' ' -f9-
}

function up {
    local dir="$(dirname "$PWD")"
    while [[ "$dir" != / ]]; do
        if echo "${dir##*/}" | grep -q -e "$1"; then
            cd "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    echo "dir matching pattern not found: $1"
    return 1
}

unset -f ff 2>/dev/null
function ff {
    local pattern=$1
    shift 1
    find "$@" -name "*$pattern*" 2>/dev/null
}
function ffi {
    local pattern=$1
    shift 1
    find "$@" -iname "*$pattern*" 2>/dev/null
}

function findpath {
    local _saveifs=$IFS
    IFS=:
    local _patharr=($PATH)
    IFS=$_saveifs
    if [[ "$1" == -* ]]; then
        find "${_patharr[@]}" "$@"
    elif [[ "$1" == *\** ]]; then
        # If pattern includes a *, use it as-is with -name
        find "${_patharr[@]}" -name "$@"
    else
        # if pattern doesn't have a *, wrap it with them
        local _name="*$1*"
        shift
        find "${_patharr[@]}" -name "$_name" "$@"
    fi
}

function cdf {
    local __dir=$(selectf -dp "$@")
    [[ -n "$__dir" ]] && [[ -d "$__dir" ]] && cd "$__dir"
}
alias cdfr="cdf -r"
alias cdfi="cdf -i"
alias cdfri="cdf -ri"

function walltime {
    local starttime=$(date -u +%s)
    "$@"
    local ret=$?
    local endtime=$(date -u +%s)
    local diff=$(($endtime - $starttime))
    local min=$(($diff / 60))
    local sec=$(($diff % 60))

    if (( $min >= 60 )); then
        local hour_s="$(($min / 60))h "
        min=$(($min % 60))
    else
        local hour_s=''
    fi

    if [[ $ret == 0 ]]; then
        local C="$(tput setaf 2)" # green
    else
        local C="$(tput setaf 1)" # red
    fi
    local R="$(tput sgr0)"

    printf >&2 '\n'
    echo -E >&2 "  $C'${*#command }' returned $ret in ${hour_s}${min}m ${sec}s$R"
    return $ret
}

[[ -n $ZSH_NAME ]] && alias make="walltime command make"

function waitproc {
    if [[ -z $1 ]]; then
        echo >&2 "Need to specify a PID!"
        return 1
    fi
    while [[ -d /proc/$1 ]]; do
        sleep 2
    done
}

# tmx function usually duplicated in ~/bin/tmx
function tmx {
    echo "TMUX"
    tmux ls &>/dev/null
    if [[ $? -eq 1 ]]
    then
        echo "starting new"
        tmux
    else
        echo "trying to attach"
        tmux attach
    fi
}

# diff the hexdump of 2 files in vimdiff
# Warning: could be slow if the files are big
function bindiff {
    if [[ "$1" == "-g" ]]; then
        local _vimdiff_cmd=gvimdiff
        shift
    else
        local _vimdiff_cmd=vimdiff
    fi
    if [[ $# != 2 ]]; then
        echo "usage: bindirr <file 1> <file 2>"
        return 1
    fi
    if [[ ! -f "$1" ]]; then
        echo "Error: $1 doesn't exist or isn't a file"
        return 1
    fi
    if [[ ! -f "$2" ]]; then
        echo "Error: $2 doesn't exist or isn't a file"
        return 1
    fi
    $_vimdiff_cmd <(hexdump -C "$1") <(hexdump -C "$2")
}
alias gbindiff="bindiff -g"

####### Bitbake/Repo/Yocto Aliases/Functions #######

# download Google's git-repo tool
function install-repo-tool {
    if [[ -n $1 ]]; then
        local _dlpath=$1
    else
        local _dlpath="$PWD/repo"
    fi
    [[ -d $_dlpath ]] && _dlpath=${_dlpath%/}/repo
    if [[ $_dlpath = /usr/* ]]; then
        local _sudo=sudo
    else
        local _sudo=
    fi
    (
        set -e
        $_sudo wget -O $_dlpath https://storage.googleapis.com/git-repo-downloads/repo
        $_sudo chmod 755 $_dlpath
    )
    if [[ $? == 0 ]]; then
        echo "Repo successfully installed to $_dlpath"
    else
        echo "Failed to install repo to $_dlpath"
    fi
}

function rbase {
    local repodir=$PWD
    while true; do
        if [[ -d $repodir/.repo ]]; then
            cd $repodir
            return 0
        elif [[ $repodir == / ]]; then
            echo 'No .repo found' >&2
            return 1
        else
            repodir=$(dirname $repodir)
        fi
    done
}
# leading space so zwild.zsh doesn't re-apply this (i.e. let myshrc_local clobber this alias)
 alias base='rbase'

function clearbbpath {
    # remove previous bitbake bin paths from PATH
    export PATH="$(path_filter PATH 'openembedded-core')"
}

function setbbpath {
    if [[ ! -d $TOP ]]; then
        echo "TOP not set or invalid! ($TOP)"
        return 1
    fi
    local _oe_candidates=( "$TOP" \
                           "$TOP/openembedded-core" \
                           "$TOP/yocto/openembedded-core" \
                        )
    local _oec
    for _oec in "${_oe_candidates[@]}"; do
        if [[ -x "$_oec/bitbake/bin/bitbake" ]]; then
            local _oedir="$_oec"
            break
        fi
    done

    if [[ -d "$_oedir" ]]; then
        clearbbpath
        export PATH=$_oedir/scripts:$_oedir/bitbake/bin:$PATH
    else
        echo "Bitbake not found! (TOP=$TOP)"
        return 1
    fi
}

function bb {
    if ( ! which bitbake &>/dev/null ); then
        setbbpath || return 1
        echo >&2 "Updated PATH"
    fi
    walltime command bitbake "$@"
}
alias bbclean='bb -c cleansstate'
for __bbalias in fetch unpack patch configure compile install; do
    alias "bb$__bbalias"="bb -c $__bbalias"
    eval "$(echo "function bbre$__bbalias { bbclean \"\$@\" && bb -c $__bbalias \"\$@\"; }")"
done
unset __bbalias

function bbrebuild {
    bbclean "$@" && bb "$@"
}

function bbenv {
    local vim="vim"
    if [[ $1 == -g ]]; then
        vim="gvim"
        shift
    fi
    if ( ! which bitbake &>/dev/null ); then
        setbbpath || return 1
        echo >&2 "Updated PATH"
    fi
    bitbake -e $1 | $vim -R -c 'set ft=bitbake' -
}

function gbbenv {
    bbenv -g "$1"
}

function localconf-parallel {
    if [[ $1 == -j* ]]; then
        local __parallel=$(sed 's/-j\(.*\)/\1/' <<<$1)
        shift
    else
        local __cpus=$(grep -c ^processor /proc/cpuinfo)
        if (( $__cpus < 16 )); then
            local __parallel=$__cpus
        else
            local __parallel=16
        fi
    fi

    if [[ $# == 0 ]]; then
        if [[ -f ./conf/local.conf ]]; then
            local __files=(./conf/local.conf)
        else
            echo >&2 "Error: no file specified and can't find conf/local.conf"
            return 1
        fi
    else
        local __files=("$@")
    fi

    sed -i.bak -e 's/^\(BB_NUMBER_THREADS\).*/\1 = "'$__parallel'"/' \
               -e 's/^\(PARALLEL_MAKE\).*/\1 = "-j'$__parallel'"/' \
               "${__files[@]}"
}

# set WORKSPACES_ROOT
__TRY_WORKSPACES=( "/export/$USER" "/workspace" )
for __ws in "${__TRY_WORKSPACES[@]}"; do
    if [[ -d $__ws ]]; then
        WORKSPACES_ROOT=$__ws
        break
    fi
done
unset __TRY_WORKSPACES __ws
function ebase {
    [[ -d "$WORKSPACES_ROOT" ]] && cd "$WORKSPACES_ROOT"
}

function sview {
    if [[ ! -d "$WORKSPACES_ROOT" ]]; then
        echo "WORKSPACES_ROOT '$WORKSPACES_ROOT' doesn't exist!"
        return 1
    fi
    if [[ -n $1 ]]; then
        local pattern="$1"
    else
        local pattern=".*"
    fi

    local choices
    choices=()
    local __name
    for __name in $(ls $WORKSPACES_ROOT | grep -Ee "$pattern"); do
        if [[ ( -d $WORKSPACES_ROOT/$__name/.repo || -e $WORKSPACES_ROOT/$__name/.git ) \
              && ! -e $WORKSPACES_ROOT/$__name/.no-sview ]]; then
            choices+=($__name)
        fi
    done

    if [[ ${#choices[@]} == 0 ]]; then
        echo "no matching view found: $pattern"
        return 1
    elif [[ ${#choices[@]} == 1 ]]; then
        [[ -n $ZSH_NAME ]] && local i=1 || local i=0
        export TOP=$WORKSPACES_ROOT/${choices[$i]}
    else
        select choice in ${choices[@]}; do
            if [[ -n $choice ]]; then
                break
            elif [[ $REPLY == "q" ]]; then
                return 0
            else
                return 1
            fi
        done
        export TOP=$WORKSPACES_ROOT/$choice
    fi
    [[ "$PWD" =~ ${TOP}(/|$) ]] || cd $TOP
}

function settop {
    if [[ -d $WORKSPACES_ROOT ]] && [[ $PWD == $WORKSPACES_ROOT/* ]]; then
        export TOP=$(pwd | sed -r 's|^('$WORKSPACES_ROOT'/[^/]+).*$|\1|')
        echo >&2 "Set TOP to $TOP"
    fi
}
# set TOP if starting in a workspace
settop


####### System/utility things #######

# gvim function for when running in cygwin
if [[ "$(uname)" == CYGWIN* ]]; then
    __vimdirs=( \
        "/cygdrive/c/Program Files/Vim/vim81"
        "/cygdrive/c/Program Files (x86)/Vim/vim81"
        "/cygdrive/c/Program Files/Vim/vim80"
        "/cygdrive/c/Program Files (x86)/Vim/vim80"
        "/cygdrive/c/Program Files (x86)/Vim/vim74")
    for __vimdir in "${__vimdirs[@]}"; do
        if [[ -e "$__vimdir/gvim.exe" ]]; then
            __WINDOWS_GVIM="$__vimdir/gvim.exe"
            break
        fi
    done
    unset __vimdir __vimdirs
    if [[ -e "$__WINDOWS_GVIM" ]]; then
        export WINDOWS_HOME="C:\\Users\\${USER}"
        function gvim() {
            if [[ -z $1 ]]; then
                SHELL='' HOME="$WINDOWS_HOME" cygstart "$__WINDOWS_GVIM"
                return
            fi
            for i in "$@"; do
                SHELL='' HOME="$WINDOWS_HOME" cygstart "$__WINDOWS_GVIM" \"$i\"
            done
        }
        function gvimf() {
            # In cygwin the selectf script can't launch gvim directly
            local _file="$(selectf -p "$@")" || return 1
            gvim "$_file"
        }
    fi
fi

# bash specific
if [[ -n $BASH ]]; then
    # immediate report background job changes
    set -b
    alias srcrc='source ~/.bashrc'
    if [[ $USER == root ]]; then
        # red prompt for root
        PS1='\[\e[1;31m\][\u@\[\e[1;34m\]\h \[\e[1;36m\]\W\[\e[1;31m\]]\$\[\e[0m\] '
    else
        # green prompt for normal users
        PS1='\[\e[1;32m\][\u@\[\e[1;34m\]\h \[\e[1;36m\]\W\[\e[1;32m\]]\$\[\e[0m\] '
    fi
fi
