#! /bin/bash
# Allen's unified custom shell config and alias script for bash and zsh

# Shell Options
export FIGNORE=".o:.pyc:~"
export EDITOR="vim"
stty -ixon
set -o ignoreeof

function pathadd
{
    ( [[ -n $1 ]] && [[ -n $2 ]] ) || return 1
    local OLDPATH
    eval OLDPATH="\$$1"

    if [[ :$OLDPATH: != :*$2*: ]]; then
        if [[ $3 == "append" ]]; then
            local NEWPATH=$OLDPATH:$2
        else
            local NEWPATH=$2:$OLDPATH
        fi
    else
        local NEWPATH=$OLDPATH
    fi
    echo -E -n "$NEWPATH" | sed -e 's/^://' -e 's/:$//'
}
[[ -d $HOME/bin ]] && export PATH="$(pathadd PATH $HOME/bin)"
[[ -d $HOME/scripts ]] && export PATH="$(pathadd PATH $HOME/scripts)"
[[ -d $HOME/lib ]] && export LD_LIBRARY_PATH="$(pathadd LD_LIBRARY_PATH $HOME/lib)"

[[ -e ~/.dircolors ]] && eval `dircolors ~/.dircolors`

# set WORKSPACES_ROOT for zsh
if [[ -n $ZSH_NAME ]]; then
    __TRY_WORKSPACES=( "/export/$USER" "/workspace" )
    for __ws in "${__TRY_WORKSPACES[@]}"; do
        if [[ -d $__ws ]]; then
            WORKSPACES_ROOT=$__ws
            break
        fi
    done
    unset __TRY_WORKSPACES __ws
fi

# Core aliases
alias ls='ls --color=auto --group-directories-first'
alias lsl='ls -alh --color=auto --group-directories-first'
alias g='egrep'
alias rmtmp='rm `ls -a | grep "~$"`'
alias df='df -h'
alias du='du -h'
alias tmus='tmux'
alias psa='ps aux'
alias psag='ps aux | grep '
alias lspath='echo $PATH | tr ":" "\n"'
alias zshrc='vim ~/.zshrc'
alias bashrc='vim ~/.bashrc'
alias myshrc='vim ~/myshrc'

alias cgrep="find -L . -name '*.[ch]' -print0 2>/dev/null | xargs -0 grep -n --color=auto"
alias hgrep="find -L . -name '*.h' -print0 2>/dev/null | xargs -0 grep -n --color=auto"
alias rgrep="find -L . -type f -print0 2>/dev/null | xargs -0 grep --color=auto"

__pmake=$(grep -c processor /proc/cpuinfo 2>/dev/null)
if [[  $__pmake > 0 ]]; then
    alias jake="make -j$__pmake"
else
    alias jake="make"
fi
unset __pmake

# networking/sudo aliases
alias ifconfig='sudo ifconfig'
alias ifdown='sudo ifdown'
alias ifup='sudo ifup'
alias ip='sudo ip'
alias ip6='sudo ip -6'
alias 'apt-get'='sudo apt-get'
alias apt='sudo apt'
alias yum='sudo yum'

# Conditional aliases
# ubuntu-specific
[[ -d /etc/update-motd.d ]] && alias update-motd='sudo run-parts /etc/update-motd.d | sudo tee /run/motd.dynamic'
[[ -x /usr/lib/update-notifier/update-motd-reboot-required ]] && alias rboot='/usr/lib/update-notifier/update-motd-reboot-required || echo "No Update Needed"'
alias findmod='find /lib/modules/$(uname -r) -name "*.ko" | grep -i'

# git aliases/functions
alias gs='git status'
alias gdn='git diff --name-status'
alias gdh='git diff HEAD'
alias gds='git diff --staged'
alias glg='git log --oneline --decorate --color --graph'
alias glga='git log --oneline --decorate --color --graph --all'
alias gll='git log --decorate --color --graph --name-status'
alias glla='git log --decorate --color --graph --name-status --all'
alias gsh='git show --decorate'
alias gshn='git show --name-status --decorate'

[[ -n $ZSH_NAME ]] && [[ -x $(which smartless) ]] && export GIT_PAGER="$(which smartless)"

# wrap gitk in a function to automatically run it in the background
function gitk {
    command gitk "$@" &
}

function gbase {
    local dir=$(git rev-parse --show-toplevel 2>/dev/null)
    [[ -n $dir ]] && cd $dir
}

function rbase {
    local repodir=$PWD
    while true; do
        if [[ -d $repodir/.repo ]]; then
            cd $repodir
            return 0
        elif [[ $repodir == / ]]; then
            echo 'No .repo found' >&2
            return 1
        else
            repodir=$(dirname $repodir)
        fi
    done
}

# Core functions
function mdcd {
    mkdir -p $1 && cd $1
}

function cdls {
    cd $1 && ls
}

unalias ll 2>/dev/null
function ll {
    ls -lAh --color=always --group-directories-first "$@" | sed 's/[ ]\+/ /g' |  cut -d' ' -f9-
}

function up {
    local dir=$(dirname $PWD)
    while [[ $dir != / ]]; do
        if echo ${dir##*/} | grep -q -e "$1"; then
            cd $dir
            return 0
        fi
        dir=$(dirname $dir)
    done
    echo "dir matching pattern not found: $1"
    return 1
}

unset -f ff 2>/dev/null
function ff {
    local pattern=$1
    shift 1
    find -L . -name "*$pattern*" "$@" 2>/dev/null
}

function ffr {
    local pattern=$1
    shift 1
    find -L . -regex ".*$pattern.*" "$@"
}

function cfind {
    find -L . -name '*.[ch]' | grep --color=auto "$@" 2>/dev/null
}

function cdf {
    local __dir=$(selectf -dp "$@")
    [[ -n "$__dir" ]] && [[ -d "$__dir" ]] && cd "$__dir"
}
alias cdfr="cdf -r"
alias cdfi="cdf -i"
alias cdfri="cdf -ri"

function walltime {
    local starttime=$(date -u +%s)
    local prog=$1
    shift
    $prog "$@"
    local ret=$?
    local endtime=$(date -u +%s)
    local diff=$(($endtime - $starttime))
    local min=$(($diff / 60))
    local sec=$(($diff % 60))

    if (( $min >= 60 )); then
        local hour_s="$(($min / 60))h "
        min=$(($min % 60))
    else
        local hour_s=''
    fi

    if [[ $ret == 0 ]]; then
        local C="$(tput setaf 2)" # green
    else
        local C="$(tput setaf 1)" # red
    fi
    local R="$(tput sgr0)"

    echo -e >&2 "\n  $C'$prog $@' returned $ret in ${hour_s}${min}m ${sec}s$R"
    return $ret
}

[[ -n $ZSH_NAME ]] && alias make="walltime make"

if which smartless &>/dev/null; then
    function page {
        $@ | $(which smartless)
    }
else
    function page {
        $@ | less
    }
fi

function waitproc {
    if [[ -z $1 ]]; then
        echo >&2 "Need to specify a PID!"
        return 1
    fi
    while [[ -d /proc/$1 ]]; do
        sleep 2
    done
}

# tmx function usually duplicated in ~/bin/tmx
function tmx {
    echo "TMUX"
    tmux ls &>/dev/null
    if [[ $? -eq 1 ]]
    then
        echo "starting new"
        tmux
    else
        echo "trying to attach"
        tmux attach
    fi
}

# download Google's git-repo tool
function install-repo-tool {
    if [[ -n $1 ]]; then
        local _dlpath=$1
    else
        local _dlpath="$PWD/repo"
    fi
    [[ -d $_dlpath ]] && _dlpath=${_dlpath%/}/repo
    if [[ $_dlpath = /usr/* ]]; then
        local _sudo=sudo
    else
        local _sudo=
    fi
    (
        set -e
        $_sudo wget -O $_dlpath https://storage.googleapis.com/git-repo-downloads/repo
        $_sudo chmod 755 $_dlpath
    )
    if [[ $? == 0 ]]; then
        echo "Repo successfully installed to $_dlpath"
    else
        echo "Failed to install repo to $_dlpath"
    fi
}

# gvim function for when running in cygwin
for __vimdir in "/cygdrive/c/Program Files (x86)/Vim/vim80" \
                "/cygdrive/c/Program Files (x86)/Vim/vim74" ; do
    if [[ -e "$__vimdir/gvim.exe" ]]; then
        __WINDOWS_GVIM="$__vimdir/gvim.exe"
        break
    fi
done
unset __vimdir
if [[ -e "$__WINDOWS_GVIM" ]]; then
    export WINDOWS_HOME='C:\Users\'${HOME##*/}
    function gvim()
    {
        if [[ -z $1 ]]; then
            SHELL='' HOME=$WINDOWS_HOME cygstart "$__WINDOWS_GVIM"
            return
        fi
        for i in "$@"; do
            SHELL='' HOME=$WINDOWS_HOME cygstart "$__WINDOWS_GVIM" --remote-tab-silent \"$i\"
        done
    }
fi

# bash specific
if [[ -n $BASH ]]; then
    # immediate report background job changes
    set -b
    alias srcrc='source ~/.bashrc'
    PS1='\[\e[1;32m\][\u@\[\e[1;34m\]\h \[\e[1;36m\]\W\[\e[1;32m\]]\$\[\e[0m\] '

# zsh specific
elif [[ -n $ZSH_NAME ]]; then
    alias srcrc='source ~/.zshrc'
    alias mmv='noglob zmv -W'
    alias dh='dirs -v'
fi
